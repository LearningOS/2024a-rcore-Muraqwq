# Lab2

## 功能实现
对于sys_get_time 和 sys_task_info, 主要在process的过程中按照与sys_write类似的方式，通过pagetable的api获取物理页，并且直接写入即可。sys_task_info的其余部分与lab1基本相同。

对于sys_mmap 和 sys_munmap， 主要做了一个对于PageTable的功能拓展。
- 在PageTable的impl中新增了 sys_alloc_mem 和 sys_delooc_mem的两个方法，实现了从页表中按照实验要求分配和释放指定长度的页表项的功能，主要使用了translate， map， unmap这几个API。
- 要获取到当前任务的页表，需要深入Task的Memoery_set，向这其中添加了向外暴露PageTable的接口 get_current_page_table
- 在Task的mod模块下同sys_task_info一样封装了主要实现两个系统调用的mmap和unmap的方法，用于process直接调用。规范了项目的结构。

## 问答题

### 1
从高到低： 63-54位缺省， 53 - 10这44位作为物理页号，7 - 0这8位是标志位。  
标志位作用：  
- V 硬件判断页表项是否合法，不合法则抛出页错误
- RWX 控制是否可读写执行，如果非法操作硬件抛出不合法操作
- U 控制这个页面是否在用户态下允许访问
- A 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
- D 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过

### 2
导致异常：
- 页错误
- 不合法操作

寄存器值：  
- stap：保存了页表的入口ppn
- spec：保存发生异常的指令地址
- stval：保存发生异常的虚拟地址

lazy策略好处：  
- 减少了内存的开销： 只需要给执行的部分分配页表项即可，不需要一次性将整个程序都分配内存。
- 启动速度快：不需要先进行所有代码段加载进内存，节省了启动时间。

内存估计：   
由于是连续存储，多级页表的内存优势不明显，这里当作单页表计算。
10GB = 2^32B, 需要页表项 10GB / 4096B = 2^20B个
一个页表项是8B，那么需要花费 2^20B * 8B = 2^28B的内存 即512MB。

描述Lazy策略：  
新增一个页表项标志位（我不太确定Access位S态如何使用），用于标识当前页是否被分配（用户角度看的分配）。所以可以先只分配一个小数额的页表项，后续页表项不分配物理内存，也不设为valid，但是设置标志位。当触发缺页中断的时候，操作系统获取对应虚拟地址，通过查页表来观察标志位是否被设置，如果是被设置了就再分配一个小数额的页表项即可。

Swap表现：
或许是一个标志位标识这个页是否换出。

### 3
更换页表：alltrap时先进行stap的切换，再保存上下文  
控制用户无法访问内核页面： 内核的页面的U位是不设置的  
单页表优势：  
- 所需要的页表项更少，所有任务共享一个内核页表
- 并且在初始化任务MemoryArea时，就不需要特定的做一个内核栈顶映射了，直接存储栈顶基址就好。
- 内核的页表也可以更加灵活？不一定是恒等映射了。

更换页表时机：  
双页表： 上下文切换时，因为需要加载内核的页表，必须切换。   
单页表： 任务切换时，因为上下文切换时，只需要控制页表项的状态即可，不需要切换，而切换任务时必须需要切换页表了。

在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
无

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

